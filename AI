local self = script.Parent
local target
local humanoid = self.Humanoid
local hrp = self.HumanoidRootPart

--Set up
self.PrimaryPart:SetNetworkOwner(nil)
for i, bodypart in pairs(self:GetDescendants()) do
	if bodypart:IsA("BasePart") then
		bodypart.CollisionGroup = "SelfUncollide"
		bodypart:SetNetworkOwner(nil)
	end
end

--Libraries
local SimplePath = require(game.ServerStorage.SimplePath)

--Workspaces
local RunService = game["Run Service"]
local PathFindingService = game["PathfindingService"]

--SimplePath
local pathParams = {
	AgentHeight = self:GetExtentsSize().Y,
	AgentCanJump = true,
	AgentCanClimb = true,
	--AgentRadius = 2, --Changing this can cause the agent to not running correctly
	--WaypointSpacing = 1,
	Costs = {
		-- Smaller = higher priority
		Climb = 1,
		Blocked = math.huge
	},
	PathSettings = {
		SupportPartialPath = true
	}
}
local path, path_ = SimplePath.new(self, pathParams)
path.Visualize = true

--Functions
local function findTarget()
	--Get the nearest
	local nearestCharacter
	local nearestDistance
	for i, character in pairs(workspace:GetChildren()) do
		if character:FindFirstChild("Humanoid") and character ~= self then
			local distance = (character.HumanoidRootPart.Position - hrp.Position).Magnitude
			if not nearestDistance or distance < nearestDistance then
				nearestDistance = distance
				nearestCharacter = character
			end
		end
	end
	return nearestCharacter, nearestDistance
end

local climb = false
local waypoints

RunService.Heartbeat:Connect(function()
	target = findTarget()
	if target then
		local target_hrp = target.HumanoidRootPart
		local target_humanoid = target.Humanoid

		local destination = target.HumanoidRootPart.Position

		if climb == false then
			path:Run(destination)
			waypoints = path_:GetWaypoints()
			for i, wp in pairs(waypoints) do
				if wp.Label == "Climb" then
					climb = true
					break
				end
			end
		else
			path:Stop()
			humanoid:MoveTo(waypoints[3].Position)
			humanoid.MoveToFinished:Wait(1)
			climb = false
		end
	end
end)
