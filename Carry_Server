local events = game.ReplicatedStorage.Events
local carry_event = events.Carry

local function HasAlignPosition(Object)
	if Object:IsA("Model") then
		local primarypart = Object.PrimaryPart
		if primarypart:FindFirstChild("IsCarrying") then
			return true
		else
			return false
		end
	else
		if Object:FindFirstChild("IsCarrying") then
			return true
		else
			return false
		end
	end
end

local function findModelThroughPrimaryPart(primarypart)
	local current = primarypart
	while current do
		if current:IsA("Model") then
			if current.PrimaryPart == primarypart then
				return current
			end
		end
		current = current.Parent
	end
	return nil
end

carry_event.OnServerInvoke = function(plr, IsCarrying, Object_)
	if IsCarrying then
		if Object_:GetNetworkOwner() ~= plr then
			Object_:SetNetworkOwner(plr)
		end
		
			local model = findModelThroughPrimaryPart(Object_)

		if model then
			for i, part in pairs(model:GetDescendants()) do
				if part:IsA("BasePart") then
					part.CollisionGroup = "SelfUncollide"
				end
			end
		else
			Object_.CollisionGroup = "SelfUncollide"
		end
	else
		local model = findModelThroughPrimaryPart(Object_)

		if model then
			for i, part in pairs(model:GetDescendants()) do
				if part:IsA("BasePart") then
					part.CollisionGroup = "Default"
				end
			end
		else
			Object_.CollisionGroup = "Default"
		end

		coroutine.wrap(function()
			task.wait()
			--local checkpoint = tick()
			while task.wait(0.2) do
				local velocity = Object_.Velocity.Magnitude
				--If lag detector not work then use "tick() - checkpoint >= 5" as a timeout
				if velocity < 0.01 or Object_.CollisionGroup == "SelfUncollide" or Object_:GetNetworkOwner() == nil then
					--Check if Object is currently not being holding then set it back to server-side
					if Object_.CollisionGroup == "Default" then
						Object_:SetNetworkOwner(nil)
						print("boom", velocity)
					else
						print("interfered")
					end
					break
				end
			end
		end)()
	end
end
