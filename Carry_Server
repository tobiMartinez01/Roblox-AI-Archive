local events = game.ReplicatedStorage.Events
local carry_event = events.Carry

local limitDistance = 6

local function HasAlignPosition(Object)
	if Object:IsA("Model") then
		local primarypart = Object.PrimaryPart
		if primarypart:FindFirstChild("IsCarrying") then
			return true
		else
			return false
		end
	else
		if Object:FindFirstChild("IsCarrying") then
			return true
		else
			return false
		end
	end
end

local function findModelThroughPrimaryPart(primarypart)
	local current = primarypart
	while current do
		if current:IsA("Model") then
			if current.PrimaryPart == primarypart then
				return current
			end
		end
		current = current.Parent
	end
	return nil
end

carry_event.OnServerInvoke = function(plr, IsCarrying, Object, camCFrame, initialCameraCFrame, initialOrientation)
	if IsCarrying then
		local AlignPosition
		local AlignOrientation
		local Object_
		
		if Object:IsA("Model") then
			Object_ = Object.PrimaryPart
			for i, part in pairs(Object:GetDescendants()) do
				if part:IsA("BasePart") then
					part.CollisionGroup = "SelfUncollide"
				end
			end
		else
			Object_ = Object
			local model = findModelThroughPrimaryPart(Object)
			if model then
				for i, part in pairs(model:GetDescendants()) do
					if part:IsA("BasePart") then
						part.CollisionGroup = "SelfUncollide"
					end
				end
			else
				Object.CollisionGroup = "SelfUncollide"
			end
		end
		
		if not HasAlignPosition(Object) then
			AlignPosition = Instance.new("AlignPosition", Object_)
			AlignPosition.Name = "IsCarrying"
			AlignPosition.Mode = Enum.PositionAlignmentMode.OneAttachment
			AlignPosition.Attachment0 = Object_:FindFirstChild("CarryPoint")
			AlignPosition.MaxForce = 10^5
			AlignPosition.MaxVelocity = math.huge
			AlignPosition.Responsiveness = 100
			
			AlignOrientation = Instance.new("AlignOrientation", Object_)
			AlignOrientation.Name = "IsCarrying_Orientation"
			AlignOrientation.Mode = Enum.OrientationAlignmentMode.OneAttachment
			AlignOrientation.Attachment0 = Object_:FindFirstChild("CarryPoint")
			AlignOrientation.MaxTorque = 10^5
			AlignOrientation.MaxAngularVelocity = math.huge
			AlignOrientation.Responsiveness = 100
			Object_:SetNetworkOwner(plr)
		else
			AlignPosition = Object_:FindFirstChild("IsCarrying")
			AlignOrientation = Object_:FindFirstChild("IsCarrying_Orientation")
		end
		AlignPosition.Position = camCFrame.Position + camCFrame.LookVector * limitDistance
		AlignOrientation.CFrame = camCFrame * initialCameraCFrame:ToObjectSpace(initialOrientation)
	else
		local Object_
		if Object:IsA("Model") then
			Object_ = Object.PrimaryPart
			for i, part in pairs(Object:GetDescendants()) do
				if part:IsA("BasePart") then
					part.CollisionGroup = "Default"
				end
			end
		else
			Object_ = Object
			Object.CollisionGroup = "Default"
		end
		coroutine.wrap(function()
			Object_:FindFirstChild("IsCarrying"):Destroy()
			Object_:FindFirstChild("IsCarrying_Orientation"):Destroy()
			task.wait()
			--local checkpoint = tick()
			while task.wait(0.2) do
				local velocity = Object_.Velocity.Magnitude
				--If lag detector not work then use "tick() - checkpoint >= 5" as a timeout
				if velocity < 0.01 or Object_:FindFirstChild("IsCarrying") or Object_:GetNetworkOwner() == nil then
					if not Object_:FindFirstChild("IsCarrying") then
						Object_:SetNetworkOwner(nil)
						print("boom", velocity)
					else
						print("interfered")
					end
					break
				end
			end
		end)()
	end
end
