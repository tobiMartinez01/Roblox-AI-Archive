local events = game.ReplicatedStorage.Events
local carry_event = events.Carry

local function HasAlignPosition(Object)
	if Object:IsA("Model") then
		local primarypart = Object.PrimaryPart
		if primarypart:FindFirstChild("IsCarrying") then
			return true
		else
			return false
		end
	else
		if Object:FindFirstChild("IsCarrying") then
			return true
		else
			return false
		end
	end
end

local function findModelThroughPrimaryPart(primarypart)
	local current = primarypart
	while current do
		if current:IsA("Model") then
			if current.PrimaryPart == primarypart then
				return current
			end
		end
		current = current.Parent
	end
	return nil
end

carry_event.OnServerInvoke = function(plr, IsCarrying, Object_)
	if IsCarrying then
		if Object_.CollisionGroup ~= "SelfUncollide" then
			local model = findModelThroughPrimaryPart(Object_)

			if model then
				for i, part in pairs(model:GetDescendants()) do
					if part:IsA("BasePart") then
						part.CollisionGroup = "SelfUncollide"
					end
				end
			else
				Object_.CollisionGroup = "SelfUncollide"
			end
		end
		Object_.Anchored = false
		if Object_:GetNetworkOwner() ~= plr then
			Object_:SetNetworkOwner(plr)
		end
	else
		if Object_.CollisionGroup ~= "Default" then
			local model = findModelThroughPrimaryPart(Object_)

			if model then
				for i, part in pairs(model:GetDescendants()) do
					if part:IsA("BasePart") then
						part.CollisionGroup = "Default"
					end
				end
			else
				Object_.CollisionGroup = "Default"
			end
		end

		coroutine.wrap(function()
			--local checkpoint = tick()
			while task.wait(0.2) do
				local velocity = Object_.Velocity.Magnitude
				--If lag detector not work then use "tick() - checkpoint >= 5" as a timeout
				if (velocity < 0.01 and Object_.CollisionGroup == "Default") or Object_.CollisionGroup == "SelfUncollide" then
					--Check if Object is currently not being holding then set it back to server-side
					if Object_.CollisionGroup == "Default" then
						Object_:SetNetworkOwner(nil)
					end
					break
				end
			end
		end)()
	end
end
