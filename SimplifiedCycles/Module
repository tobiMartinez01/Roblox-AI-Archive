local wanderer = {}
--Set to be same indexes
wanderer.__index = wanderer

--Workspaces
local RunService = game["Run Service"]
local PathFindingService = game["PathfindingService"]

--Libraries
local NoobPath = require(game.ServerStorage.NoobPath)

local random = math.random

function wanderer.new(agent, path, costs, defaultDebounce, randomized)
	local new_wander = {}
	--Bind wander to be new_wander
	setmetatable(new_wander, wanderer)
	--Insert but OOP style :P aka custom properties
	new_wander.Agent = agent
	new_wander.Path = path
	new_wander.Debounce = defaultDebounce
	new_wander.Randomized = randomized

	--Creating Operator
	local pathParams = {
		AgentHeight = agent:GetExtentsSize().Y,
		AgentCanJump = true,
		AgentCanClimb = true,
		--AgentRadius = 2, --Changing this can cause the agent to not running correctly
		--WaypointSpacing = 1.5,
		Costs = costs,
		PathSettings = {
			SupportPartialPath = true
		}
	}
	--Set up Operator
	new_wander.PathOperator = NoobPath.Humanoid(agent, pathParams)

	--Setting collisionGroup
	for i, bodypart in pairs(agent:GetDescendants()) do
		if bodypart:IsA("BasePart") then
			bodypart.CollisionGroup = "SelfUncollide"
		end
	end

	--Stares
	local attachment0 = Instance.new("Attachment", agent.HumanoidRootPart)
	attachment0.CFrame = CFrame.Angles(0, math.rad(90), 0)

	local alignOrientation = Instance.new("AlignOrientation", attachment0)
	alignOrientation.MaxTorque = 10^5
	alignOrientation.MaxAngularVelocity = 100
	alignOrientation.Responsiveness = 20
	alignOrientation.Mode = Enum.OrientationAlignmentMode.OneAttachment
	alignOrientation.AlignType = Enum.AlignType.PrimaryAxisLookAt
	alignOrientation.ReactionTorqueEnabled = true
	alignOrientation.Attachment0 = attachment0
	alignOrientation.Enabled = false

	new_wander.Attachment0 = attachment0
	new_wander.AlignOrientation = alignOrientation

	--Events

	--Reached event
	new_wander.ReachedBindable = Instance.new("BindableEvent")
	new_wander.Reached = new_wander.ReachedBindable.Event 


	--Jump
	local humanoid = agent.Humanoid
	local hrp = agent.HumanoidRootPart

	coroutine.wrap(function()
		while task.wait() do
			if humanoid:GetState() ~= Enum.HumanoidStateType.Climbing and not new_wander.PathOperator.Idle then
				local origin = hrp.CFrame + (hrp.CFrame.LookVector * (hrp.Size.Z/2)) 
				local size = Vector3.new(2, hrp.Size.Y, 2)
				local overlap = OverlapParams.new()
				overlap.RespectCanCollide = true
				overlap.FilterType = Enum.RaycastFilterType.Exclude
				overlap.FilterDescendantsInstances = {npc}
				local obstacle = workspace:GetPartBoundsInBox(origin, size, overlap)

				for i, part in pairs(obstacle) do
					if not part:FindFirstAncestorWhichIsA('Model'):FindFirstChild("Humanoid") then
						if part.ClassName ~= "TrussPart" then
							if part.Transparency ~= 1 then
								local sides = {
									front = part.CFrame.LookVector * (part.Size.Z / 2)+part.Position,
									back = -part.CFrame.LookVector * (part.Size.Z / 2)+part.Position,
									right = part.CFrame.RightVector * (part.Size.X / 2)+part.Position,
									left = -part.CFrame.RightVector * (part.Size.X / 2)+part.Position,
									up = part.CFrame.UpVector * (part.Size.Y / 2)+part.Position,
									down = -part.CFrame.UpVector * (part.Size.Y / 2)+part.Position,
								}

								local highestSurface = nil
								local highestY = -math.huge  -- Start with a very low value to ensure any surface is higher

								for side, position in pairs(sides) do
									if position.Y > highestY then
										highestY = position.Y
										highestSurface = side
									end
								end

								if (humanoid.JumpPower^2 / (2*workspace.Gravity)) >= (highestY - hrp.Position.Y) then
									humanoid.Jump = true
								end
							end
						end
					end
				end
			end
		end
	end)()

	return new_wander
end

function invokeReached(self, currentIndex)
	self.ReachedBindable:Fire(currentIndex)
end

function lookEnable(self)
	self.AlignOrientation.Enabled = true
end

function lookDisable(self)
	self.AlignOrientation.Enabled = false
end

local function Run(self, npc, pathFolder, debounce, randomized)
	--Calling agent
	local humanoid = npc.Humanoid
	local hrp = npc.HumanoidRootPart

	--Caling pathOperator
	local operator = self.PathOperator

	--Params
	local raycastParams = RaycastParams.new()
	raycastParams.FilterDescendantsInstances = {npc}
	raycastParams.FilterType = Enum.RaycastFilterType.Exclude
	raycastParams.RespectCanCollide = true
	raycastParams.IgnoreWater = true

	local pathWaypoints = {}

	--Getting waypoints data
	local export_

	if type(pathFolder) == "table" then
		export_= pathFolder
	else
		export_= pathFolder:GetChildren()
	end

	for i, waypoint in pairs(export_) do
		if waypoint:IsA("BasePart") then
			table.insert(pathWaypoints, waypoint)
		end
	end
	--Sort data
	table.sort(pathWaypoints, function(a, b)
		return tonumber(a.Name) < tonumber(b.Name)
	end)

	--Variables
	local currentIndex
	local currentWaypoint

	local lastWaypoint = nil
	local lastWaypoint2 = nil

	local reached = 0

	--Finding next waypoint
	local function nextIndex(selectedPath)
		--Saving last waypoints (for effective rng)
		lastWaypoint2 = lastWaypoint
		lastWaypoint = currentWaypoint

		--Overidding debounce and randomized
		if currentWaypoint then
			debounce = currentWaypoint:GetAttribute('Debounce')
			randomized = currentWaypoint:GetAttribute('Randomized')
		end

		if randomized then
			--Random
			repeat
				currentIndex = random(1, #selectedPath)
				currentWaypoint = selectedPath[currentIndex]
			until (#selectedPath < 4 or (currentWaypoint ~= lastWaypoint and currentWaypoint ~= lastWaypoint2)) and selectedPath[currentIndex]:GetAttribute('Unvailable') == nil
		else
			--In order
			currentIndex+=1
			
			if currentIndex > #pathWaypoints then
				currentIndex = 1
			end
			
		end
		
		currentWaypoint = selectedPath[currentIndex]
		currentWaypoint:SetAttribute("Unavailable", true)
	end

	--Walk
	local function goTo(selectedPath)
		--Find next index
		nextIndex(selectedPath)
		--Yield depending on previous waypoint set Debounce
		if reached == 0 and pathFolder == self.Path  then
			task.wait(0)
		else
			task.wait(debounce)
		end

		--Connections
		local error_
		local trapped_

		error_ = operator.Error:Connect(function()
			operator:Run(currentWaypoint.Position)
		end)

		trapped_ = operator.Trapped:Connect(function()
			operator:Run(currentWaypoint.Position)
		end)

		--Cleanup and stopping the loop
		local reachedEvent

		reachedEvent = operator.Reached:Connect(function()
			reached+=1
			--Cleanup
			currentWaypoint:SetAttribute("Unavailable", nil)
			error_:Disconnect()
			trapped_:Disconnect()
			reachedEvent:Disconnect()
			--Loop
			goTo(pathWaypoints)
		end)

		--Run
		operator:Run(currentWaypoint.Position)
	end

	--Run for the first time
	goTo(pathWaypoints)
end

function wanderer:Run()
	Run(self, self.Agent, self.Path, self.Debounce, self.Randomized)
end

return wanderer
