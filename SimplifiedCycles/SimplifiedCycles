-- Utility Functions
local function sortTable(t)
	table.sort(t, function(a, b)
		return tonumber(a.Name) < tonumber(b.Name)
	end)
end

local function importWaypoints(folder)
	local waypoints = {}
	for _, waypoint in ipairs(folder:GetChildren()) do
		if waypoint:IsA("BasePart") then
			table.insert(waypoints, waypoint)
		end
	end
	sortTable(waypoints)
	return waypoints
end

local function clearConnections(connections)
	for key, conn in pairs(connections) do
		if conn then
			conn:Disconnect()
			connections[key] = nil
		end
	end
end

-----------------------------------------------------------
-- Agent Module
local agent = {}
agent.__index = agent

-- Services
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local PathFindingService = game:GetService("PathfindingService")
local ServerStorage = game:GetService("ServerStorage")

-- Modules
local NoobPath = require(ServerStorage.NoobPath)

-- Constructor
function agent.new(character, costs)
	local self = setmetatable({
		events = {
			Reached = Instance.new("BindableEvent"),
			Next = Instance.new("BindableEvent")
		},
		connections = {}
	}, agent)

	-- Store references
	self.Character = character
	self.Reached = self.events.Reached.Event
	self.Next = self.events.Next.Event

	-- Ensure server simulation for all parts in the character
	for _, part in pairs(character:GetDescendants()) do
		if part:IsA("BasePart") then
			part:SetNetworkOwner(nil)
		end
	end

	-- Setup pathfinding parameters using NoobPath module
	local pathParams = {
		AgentHeight = character:GetExtentsSize().Y,
		AgentCanJump = true,
		AgentCanClimb = true,
		Costs = costs,
		PathSettings = {
			SupportPartialPath = true
		}
	}
	self.Path = NoobPath.Humanoid(character, pathParams)

	-- Jump Mechanic (run in a coroutine)
	local humanoid = character.Humanoid
	local hrp = character.HumanoidRootPart

	coroutine.wrap(function()
		-- Using a moderate delay reduces the frequency of heavy collision queries
		while RunService.Heartbeat:Wait(0.5) do
			-- Only run if not climbing and the path is active (not idle)
			if humanoid:GetState() ~= Enum.HumanoidStateType.Climbing and not self.Path.Idle then
				local origin = CFrame.new(hrp.Position + (hrp.CFrame.LookVector * (hrp.Size.Z / 2)))
				local size = Vector3.new(0.1, hrp.Size.Y, 0.1)

				-- Create a new OverlapParams for this query
				local overlap = OverlapParams.new()
				overlap.RespectCanCollide = true
				overlap.FilterType = Enum.RaycastFilterType.Exclude
				overlap.FilterDescendantsInstances = { character }

				-- Query obstacles in front of the NPC
				local obstacles = workspace:GetPartBoundsInBox(origin, size, overlap)
				for _, part in pairs(obstacles) do
					-- Skip parts belonging to models that have a Humanoid (e.g. other characters)
					if not part:FindFirstAncestorWhichIsA('Model'):FindFirstChild("Humanoid") then
						-- Exclude specific parts (e.g. TrussPart) and invisible parts
						if part.ClassName ~= "TrussPart" and part.Transparency ~= 1 then
							-- Calculate candidate surfaces for jumping (front, back, right, left, up, down)
							local sides = {
								front = part.CFrame.LookVector * (part.Size.Z / 2) + part.Position,
								back = -part.CFrame.LookVector * (part.Size.Z / 2) + part.Position,
								right = part.CFrame.RightVector * (part.Size.X / 2) + part.Position,
								left = -part.CFrame.RightVector * (part.Size.X / 2) + part.Position,
								up = part.CFrame.UpVector * (part.Size.Y / 2) + part.Position,
								down = -part.CFrame.UpVector * (part.Size.Y / 2) + part.Position,
							}
							-- Find the highest surface
							local highestSurface, highestY = nil, -math.huge
							for side, pos in pairs(sides) do
								if pos.Y > highestY then
									highestY = pos.Y
									highestSurface = side
								end
							end
							-- If the jump height is sufficient, then jump
							if (humanoid.JumpPower^2 / (workspace.Gravity * 2)) >= (highestY - hrp.Position.Y) then
								humanoid.Jump = true
							end
						end
					end
				end
			end
		end
	end)()

	return self
end

-----------------------------------------------------------
-- Main Agent Methods

function agent:Run(waypoints, UPPER_PATH, SUB_PATH)
	-- Character and Animation references
	local CHARACTER = self.Character
	local HRP = CHARACTER.HumanoidRootPart
	local HUMANOID = CHARACTER.Humanoid
	local ANIMATOR = HUMANOID.Animator
	local path = self.Path

	-- Import and store the path waypoints
	local pathWaypoints = importWaypoints(waypoints)
	if not self.MainPath then
		self.MainPath = waypoints
	end

	-- Initialize indices and counters
	local CURRENT_INDEX = 1
	local LAST_INDEX = nil
	local FINISHED = 0
	local UPPER_CURRENT_INDEX, UPPER_LAST_INDEX, UPPER_FINISHED

	-- If an upper path is provided, restore its indices
	if UPPER_PATH then
		UPPER_CURRENT_INDEX = UPPER_PATH.CURRENT_INDEX
		UPPER_LAST_INDEX = UPPER_PATH.LAST_INDEX
		UPPER_FINISHED = UPPER_PATH.FINISHED
	end
	-- Restore sub-path indices if provided
	if SUB_PATH then
		CURRENT_INDEX = SUB_PATH.CURRENT_INDEX
		LAST_INDEX = SUB_PATH.LAST_INDEX
		FINISHED = SUB_PATH.FINISHED
	end

	-- Local helper: update to next waypoint index
	local function findNextIndex()
		LAST_INDEX = CURRENT_INDEX
		local reachedWP = pathWaypoints[LAST_INDEX]
		if reachedWP then
			reachedWP:SetAttribute("Unavailable", nil)
			self.Debounce = reachedWP:GetAttribute("Debounce")
			self.Randomized = reachedWP:GetAttribute("Randomized")
		end

		if self.Randomized then
			repeat 
				CURRENT_INDEX = math.random(1, #pathWaypoints)
			until (#pathWaypoints < 2 or CURRENT_INDEX ~= LAST_INDEX)
				and not pathWaypoints[CURRENT_INDEX]:GetAttribute("Unavailable")
		else
			CURRENT_INDEX = CURRENT_INDEX % #pathWaypoints + 1
		end
		local nextWP = pathWaypoints[CURRENT_INDEX]
		nextWP:SetAttribute("Unavailable", true)
	end

	-- Local function: control walking behavior and handle reached waypoint
	local function walk()
		local function reached()
			FINISHED = FINISHED + 1
			local reachedWP = pathWaypoints[CURRENT_INDEX]
			findNextIndex()
			clearConnections(self.connections)

			-- Handle orientation and animations if an Attachment exists
			local attach = reachedWP:FindFirstChildWhichIsA("Attachment")
			if attach then
				local ORIGIN = reachedWP.Position * Vector3.new(1, 0, 1) + HRP.Position * Vector3.new(0, 1, 0)
				local LOOK_AT = attach.WorldCFrame.Position * Vector3.new(1, 0, 1) + HRP.Position * Vector3.new(0, 1, 0)

				-- Wait until the NPC is in an idle state
				repeat 
					RunService.Heartbeat:Wait()
				until HUMANOID:GetState() ~= Enum.HumanoidStateType.Climbing 
					and HUMANOID:GetState() ~= Enum.HumanoidStateType.Jumping 
					and HUMANOID:GetState() ~= Enum.HumanoidStateType.Freefall 
					and HUMANOID.FloorMaterial ~= Enum.Material.Air 
					and HRP.Velocity.Magnitude < 0.01 
					and path.Idle

				-- Anchor momentarily to avoid disturbance
				HRP.Anchored = true

				-- Tween rotation toward target direction
				local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut)
				local lookTween = TweenService:Create(HRP, tweenInfo, { CFrame = CFrame.new(ORIGIN, LOOK_AT) })
				lookTween:Play()

				-- Play entrance animation if available
				local enterAnimObj = reachedWP:FindFirstChild("Enter")
				local enterTrack
				if enterAnimObj and enterAnimObj.Value then
					enterTrack = ANIMATOR:LoadAnimation(enterAnimObj.Value)
					enterTrack.Looped = false
					enterTrack.Priority = Enum.AnimationPriority.Action2
					enterTrack:Play()
				end

				-- Handle interact animations (choose one at random)
				local interactAnims = {}
				local interactAnimId
				for _, animObj in pairs(reachedWP:GetChildren()) do
					if animObj:IsA("ObjectValue") and animObj.Name ~= "Enter" and animObj.Name ~= "Leave" then
						table.insert(interactAnims, animObj)
					end
				end
				if #interactAnims > 0 then
					local chosen = interactAnims[math.random(1, #interactAnims)]
					if chosen.Value then
						interactAnimId = chosen.Value.AnimationId
						self.INTERACTION = ANIMATOR:LoadAnimation(chosen.Value)
						self.INTERACTION.Priority = Enum.AnimationPriority.Action
					end
				end

				-- Fire the Reached event with optional interact animation id
				self.events.Reached:Fire(reachedWP, interactAnimId)

				-- If there is an interaction animation, wait for entrance and play the interaction
				if self.INTERACTION then
					if enterTrack then
						enterTrack.Stopped:Wait()
					end
					self.INTERACTION:Play()
					if not self.INTERACTION.Looped then
						self.INTERACTION.Stopped:Wait()
					end
				end
			end

			-- If no interaction, fire the Reached event
			if not self.INTERACTION then
				self.events.Reached:Fire(reachedWP, nil)
			end

			-- Check for sub-waypoints
			local subWaypoints = importWaypoints(reachedWP)
			if #subWaypoints > 0 then
				local sendData = {
					CURRENT_INDEX = CURRENT_INDEX,
					LAST_INDEX = LAST_INDEX,
					FINISHED = FINISHED,
				}
				self:Run(reachedWP, sendData)
			else
				if FINISHED < #pathWaypoints or waypoints == self.MainPath then
					walk()
				else
					if reachedWP.Parent and reachedWP.Parent.Parent then
						local upperWaypoints = importWaypoints(reachedWP.Parent.Parent)
						local sendData = {
							CURRENT_INDEX = UPPER_CURRENT_INDEX,
							LAST_INDEX = UPPER_LAST_INDEX,
							FINISHED = FINISHED,
						}
						self:Run(reachedWP.Parent.Parent, nil, sendData)
					end
				end
			end
		end

		local currentWP = pathWaypoints[CURRENT_INDEX]

		-- Set up event connections and store them in self.connections for later cleanup
		self.connections.TrappedEvent = path.Trapped:Connect(function()
			path:Run(currentWP.Position)
		end)
		self.connections.ErrorEvent = path.Error:Connect(function()
			path:Run(currentWP.Position)
		end)
		self.connections.ReachedEvent = path.Reached:Connect(function()
			reached()
		end)

		-- Check if the NPC has already reached the waypoint (by measuring distance)
		local distance = ((HRP.Position * Vector3.new(1, 0, 1) + currentWP.Position * Vector3.new(0, 1, 0)) - currentWP.Position).Magnitude
		if distance <= 0.01 then
			reached()
		else
			task.wait(self.Debounce)
			self.events.Next:Fire(currentWP)
			-- Stop current interaction, if any
			if self.INTERACTION then
				self.INTERACTION:Stop()
				self.INTERACTION = nil
			end
			-- Handle exit animation from previous waypoint if available
			if pathWaypoints[LAST_INDEX] then
				local leaveAnimObj = pathWaypoints[LAST_INDEX]:FindFirstChild("Leave")
				if leaveAnimObj and leaveAnimObj.Value then
					local leaveTrack = ANIMATOR:LoadAnimation(leaveAnimObj.Value)
					leaveTrack.Looped = false
					leaveTrack.Priority = Enum.AnimationPriority.Action2
					leaveTrack:Play()
					leaveTrack.Stopped:Wait()
				end
			end
			HRP.Anchored = false
			path:Run(currentWP.Position)
		end
	end

	walk()
end

return agent
