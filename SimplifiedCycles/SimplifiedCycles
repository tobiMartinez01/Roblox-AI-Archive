-- Utility Functions
local function sortTable(t)
    table.sort(t, function(a, b)
        return tonumber(a.Name) < tonumber(b.Name)
    end)
end

local function importWaypoints(folder)
    local waypoints = {}
    for _, waypoint in ipairs(folder:GetChildren()) do
        if waypoint:IsA("BasePart") then
            table.insert(waypoints, waypoint)
        end
    end
    sortTable(waypoints)
    return waypoints
end

local function clearConnections(connections)
    for key, conn in pairs(connections) do
        if conn then
            conn:Disconnect()
            connections[key] = nil
        end
    end
end

-----------------------------------------------------------
-- Agent Module
local agent = {}
agent.__index = agent

-- Services
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local PathfindingService = game:GetService("PathfindingService")
local ServerStorage = game:GetService("ServerStorage")

-- Modules
local NoobPath = require(ServerStorage.NoobPath)

-- Constructor
function agent.new(character, costs)
    local self = setmetatable({
        events = {
            Reached = Instance.new("BindableEvent"),
            Next = Instance.new("BindableEvent")
        },
        connections = {}
    }, agent)

    self.Character = character
    self.Reached = self.events.Reached.Event
    self.Next = self.events.Next.Event

    local pathParams = {
        AgentHeight = character:GetExtentsSize().Y,
        AgentCanJump = true,
        AgentCanClimb = true,
        Costs = costs,
        WaypointSpacing = 8,
        PathSettings = {
            SupportPartialPath = true
        }
    }
    self.Path = NoobPath.Humanoid(character, pathParams)
    --self.Path.Visualize = true -- Uncomment to visualize paths

    return self
end

-----------------------------------------------------------
-- Main Agent Methods

function agent:Run(PATH_FOLDER)
	self.Thread = coroutine.create(function()
		local CHARACTER = self.Character
		local HRP = self.HumanoidRootPart
		local HUMANOID = self.Humanoid
		
		local PATH = self.Path
		
		local function runPath(folder)		
			local path = importWaypoints(folder)
			
			if #path > 0 then
				local INDEX = 1
				local FINISHED = 0
				local WAYPOINT = path[INDEX]
				
				local function gotoWaypoint()
					-- Next index
					if self.Randomized then
						repeat 
							INDEX = math.random(1, #path)
						until (not path[INDEX]:GetAttribute("Unavailable") and path[INDEX] ~= WAYPOINT) or #path < 2
					else
						repeat
							INDEX = (INDEX % #path) + 1
						until not path[INDEX]:GetAttribute("Unavailable")
					end

					WAYPOINT = path[INDEX]

					-- Occupied
					WAYPOINT:SetAttribute("Unavailable", true)

					-- Yield
					task.wait(self.Debounce or 0)

					-- Run
					PATH:Run(WAYPOINT.Position)

					-- Finished
					PATH.Reached:Wait()

					-- Overriding values
					FINISHED+=1
					WAYPOINT:SetAttribute("Unavailable", nil)
					
					self.Debounce = WAYPOINT:GetAttribute("Debounce") or 0
					self.Randomized = WAYPOINT:GetAttribute("Randomized") or false

					-- Sub-waypoints
					runPath(WAYPOINT)

					-- Continue same level path
					if FINISHED < #path or folder == PATH_FOLDER then
						gotoWaypoint()
					end
				end

				gotoWaypoint()
			end
		end

		runPath(PATH_FOLDER)
	end)

    coroutine.resume(self.Thread)
end

return agent
