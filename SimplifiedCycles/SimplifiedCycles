-- Utility Functions
local function sortTable(t)
	table.sort(t, function(a, b)
		return tonumber(a.Name) < tonumber(b.Name)
	end)
end

local function importWaypoints(folder)
	local waypoints = {}
	for _, waypoint in ipairs(folder:GetChildren()) do
		if waypoint:IsA("BasePart") and not waypoint:GetAttribute("Unavailable") then
			table.insert(waypoints, waypoint)
		end
	end
	sortTable(waypoints)
	return waypoints
end

local function findAnimationTrackInTable(t, animId)
	for i, v in pairs(t) do
		if v.Animation.AnimationId == animId then
			return v
		end
		
		findAnimationTrackInTable(v, animId)
	end
	
	return false
end

local function clearConnections(connections)
	for key, conn in pairs(connections) do
		if conn then
			conn:Disconnect()
			connections[key] = nil
		end
	end
end

-----------------------------------------------------------
-- Agent Module
local agent = {}
agent.__index = agent

-- Services
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local PathfindingService = game:GetService("PathfindingService")
local ServerStorage = game:GetService("ServerStorage")

-- Modules
local NoobPath = require(ServerStorage.NoobPath)

-- Constructor
function agent.new(character, costs)
	local self = setmetatable({
		events = {
			Reached = Instance.new("BindableEvent"),
			Next = Instance.new("BindableEvent")
		},
		connections = {}
	}, agent)

	self.Character = character
	self.Reached = self.events.Reached.Event
	self.Next = self.events.Next.Event

	local pathParams = {
		AgentHeight = character:GetExtentsSize().Y,
		AgentCanJump = true,
		AgentCanClimb = true,
		Costs = costs,
		WaypointSpacing = 8,
		PathSettings = {
			SupportPartialPath = true
		}
	}
	self.Path = NoobPath.Humanoid(character, pathParams)
	self.Path.Partial = true
	self.Path.Speed = character.Humanoid.WalkSpeed

	character.Humanoid:GetPropertyChangedSignal('WalkSpeed'):Connect(function()
		self.Path.Speed = character.Humanoid.WalkSpeed
	end)
	--self.Path.Visualize = true -- Uncomment to visualize paths

	return self
end

-----------------------------------------------------------
-- Main Agent Methods

function agent:Run(PATH_FOLDER)
	self.Thread = coroutine.create(function()
		local CHARACTER = self.Character
		local HRP = CHARACTER.HumanoidRootPart
		local HUMANOID = CHARACTER.Humanoid
		local ANIMATOR = HUMANOID.Animator

		local PATH = self.Path
		
		local animationTracks = {}
		
		-- Load animation
		for i, objValue in pairs(PATH_FOLDER:GetDescendants()) do
			if objValue:IsA("ObjectValue") and objValue.Value then
				table.insert(animationTracks, ANIMATOR:LoadAnimation(objValue.Value))
			end
		end

		local function runPath(folder)
			local path = importWaypoints(folder)

			if #path > 0 then
				local INDEX = 0
				local LAST_INDEX  = 0
				local FINISHED = 0
				local WAYPOINT = path[INDEX] 

				local function goToWaypoint()
					-- Next index
					if self.Randomized then
						repeat 
							INDEX = math.random(1, #path)
						until (path[INDEX] ~= WAYPOINT and INDEX ~= LAST_INDEX)
					else
						INDEX = (INDEX % #path) + 1
					end

					-- Occupied
					LAST_INDEX = INDEX
					local CURRENT_WAYPOINT = path[INDEX]
					CURRENT_WAYPOINT:SetAttribute("Unavailable", true)

					-- Yield
					task.wait(self.Debounce or 0)

					-- Fire event
					self.events.Next:Fire(CURRENT_WAYPOINT)
					PATH:Run(CURRENT_WAYPOINT.Position)

					-- Finished
					PATH.Reached:Wait()

					-- Overriding values
					FINISHED+=1
					CURRENT_WAYPOINT:SetAttribute("Unavailable", nil)
					self.Debounce = CURRENT_WAYPOINT:GetAttribute("Debounce") or 0
					self.Randomized = CURRENT_WAYPOINT:GetAttribute("Randomized") or false

					-- Sub-waypoints
					runPath(CURRENT_WAYPOINT)

					-- Continue same level path
					if FINISHED < #path or folder == PATH_FOLDER then
						goToWaypoint()
					end
				end

				goToWaypoint()
			end
		end

		runPath(PATH_FOLDER)
	end)

	coroutine.resume(self.Thread)
end

return agent
