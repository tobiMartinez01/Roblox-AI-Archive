local agent = {}
agent.__index = agent

--Services
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local PathFindingService = game:GetService("PathfindingService")

local ServerStorage = game:GetService("ServerStorage")

--Modules
local NoobPath = require(ServerStorage.NoobPath)

function agent.new(character, costs)
	local newAgent = {
		events = {
			Reached = Instance.new("BindableEvent"),
			Next = Instance.new("BindableEvent")
		}
	}

	--Asign a new metatable to agent
	local self = setmetatable(newAgent, agent)

	--Variables
	self.Character = character
	self.Reached = self.events.Reached.Event
	self.Next = self.events.Next.Event

	--Creating NoobPath
	local pathParams = {
		AgentHeight = character:GetExtentsSize().Y,
		AgentCanJump = true,
		AgentCanClimb = true,
		Costs = costs,
		PathSettings = {
			SupportPartialPath = true
		}
	}

	self.Path = NoobPath.Humanoid(character, pathParams)

	--Jump mechanic
	local humanoid = character.Humanoid
	local hrp = character.HumanoidRootPart

	coroutine.wrap(function()
		while RunService.Heartbeat:Wait() do
			if humanoid:GetState() ~= Enum.HumanoidStateType.Climbing and not self.Path.Idle then
				local origin = CFrame.new(hrp.Position + (hrp.CFrame.LookVector * (hrp.Size.Z / 2)))
				local size = Vector3.new(0.1, hrp.Size.Y, 0.1)

				local overlap = OverlapParams.new()
				overlap.RespectCanCollide = true
				overlap.FilterType = Enum.RaycastFilterType.Exclude
				overlap.FilterDescendantsInstances = {character}

				local obstacle = workspace:GetPartBoundsInBox(origin, size, overlap)

				for i, part in pairs(obstacle) do
					if not part:FindFirstAncestorWhichIsA('Model'):FindFirstChild("Humanoid") then
						if part.ClassName ~= "TrussPart" then
							if part.Transparency ~= 1 then
								local sides = {
									front = part.CFrame.LookVector * (part.Size.Z / 2)+part.Position,
									back = -part.CFrame.LookVector * (part.Size.Z / 2)+part.Position,
									right = part.CFrame.RightVector * (part.Size.X / 2)+part.Position,
									left = -part.CFrame.RightVector * (part.Size.X / 2)+part.Position,
									up = part.CFrame.UpVector * (part.Size.Y / 2)+part.Position,
									down = -part.CFrame.UpVector * (part.Size.Y / 2)+part.Position,
								}

								local highestSurface = nil
								local highestY = -math.huge  -- Start with a very low value to ensure any surface is higher

								for side, position in pairs(sides) do
									if position.Y > highestY then
										highestY = position.Y
										highestSurface = side
									end
								end

								if (humanoid.JumpPower^2 / (workspace.Gravity * 2)) >= (highestY - hrp.Position.Y) then
									humanoid.Jump = true
								end
							end
						end
					end
				end
			end
		end
	end)()

	return self
end

function sortTable(table_)
	table.sort(table_, function(a, b)
		return tonumber(a.Name) < tonumber(b.Name)
	end)
end

function importWaypoints(table_)
	local sendData = {}

	--Inserting waypoints to sendData
	for i, waypoint in pairs(table_:GetChildren()) do
		if waypoint:IsA("BasePart") then
			table.insert(sendData, waypoint)
		end
	end

	--Sort waypoints
	sortTable(sendData)

	return sendData
end

function agent:Run(waypoints, UPPER_PATH, SUB_PATH)
	--Character variables
	local Character = self.Character
	local humanoid = Character.Humanoid
	local hrp = Character.HumanoidRootPart

	local path = self.Path
	local ANIMATOR = humanoid.Animator

	--Thresholds
	local reachedThreshold = 0.01

	--Getting waypoints
	local pathWaypoints = importWaypoints(waypoints)

	--Saving main path
	if not self.MainPath then
		self.MainPath = waypoints
	end

	--Path variables
	local CURRENT_INDEX = 0
	local LAST_INDEX
	local LAST_OF_LAST_INDEX
	local FINISHED = 0

	local UPPER_CURRENT_INDEX
	local UPPER_LAST_INDEX
	local UPPER_LAST_OF_LAST_INDEX
	local UPPER_FINISHED

	--Saving Upper path
	if UPPER_PATH then
		UPPER_CURRENT_INDEX = UPPER_PATH.CURRENT_INDEX
		UPPER_LAST_INDEX = UPPER_PATH.LAST_INDEX
		UPPER_LAST_OF_LAST_INDEX = UPPER_PATH.LAST_OF_LAST_INDEX
		UPPER_FINISHED = UPPER_PATH.FINISHED
	end

	--Restoring from sub path
	if SUB_PATH then
		CURRENT_INDEX = SUB_PATH.CURRENT_INDEX
		LAST_INDEX = SUB_PATH.LAST_INDEX
		LAST_OF_LAST_INDEX = SUB_PATH.LAST_OF_LAST_INDEX
		FINISHED = SUB_PATH.FINISHED
	end

	--Finding new index
	local function findNextIndex()
		--Saving indexes
		LAST_OF_LAST_INDEX = LAST_INDEX
		LAST_INDEX = CURRENT_INDEX

		--Overriding debounce and randomized
		local REACHED_WAYPOINT = pathWaypoints[LAST_INDEX]

		if REACHED_WAYPOINT and not UPPER_PATH and not SUB_PATH then
			self.Debounce = REACHED_WAYPOINT:GetAttribute("Debounce")
			self.Randomized = REACHED_WAYPOINT:GetAttribute("Randomized")
		elseif UPPER_PATH then
			self.Debounce = UPPER_PATH.DEBOUNCE
			self.Randomized = UPPER_PATH.RANDOMIZED
		elseif SUB_PATH then
			self.Debounce = SUB_PATH.DEBOUNCE
			self.Randomized = SUB_PATH.RANDOMIZED
		end

		--Next index
		if self.Randomized then
			--Random new index until we get a brand new waypoint
			repeat
				CURRENT_INDEX = math.random(1, #pathWaypoints)
			until (#pathWaypoints < 4 or (pathWaypoints[CURRENT_INDEX] ~= pathWaypoints[LAST_INDEX] and pathWaypoints[CURRENT_INDEX] ~= pathWaypoints[LAST_OF_LAST_INDEX])) and not pathWaypoints[CURRENT_INDEX]:GetAttribute("Unavailable") and pathWaypoints[CURRENT_INDEX] ~= pathWaypoints[LAST_INDEX]
		else
			--Following the order
			CURRENT_INDEX+=1

			--Restart if finished the path
			if CURRENT_INDEX > #pathWaypoints then
				CURRENT_INDEX = 1
			end
		end


		--If CURRENT_INDEX was manually overrided
		--[[
		if self.StartFrom then
			CURRENT_INDEX = self.StartFrom
			self.StartFrom = nil
		end
		]]
	end

	local function goToNextWaypoint()
		--Get next index
		findNextIndex()

		local CURRENT_WAYPOINT = pathWaypoints[CURRENT_INDEX]

		local function isReached()
			--Making sure the path has to be idle
			if not path.Idle then
				path:Stop()
			end

			--Record
			FINISHED+=1

			--Clean up
			self.REACHED_EVENT:Disconnect()
			self.ERROR_EVENT:Disconnect()
			self.TRAPPED_EVENT:Disconnect()

			local REACHED_WAYPOINT = CURRENT_WAYPOINT

			local INTERACTION = nil

			local ATTACHMENT = REACHED_WAYPOINT:FindFirstChildWhichIsA("Attachment")
			--Detect if the npc has to stare at a specific position
			if ATTACHMENT then
				--Make the NPC look to the attachment
				local ORIGIN = REACHED_WAYPOINT.Position * Vector3.new(1, 0, 1) + hrp.Position * Vector3.new(0, 1, 0)
				local LOOK_AT = ATTACHMENT.WorldCFrame.Position * Vector3.new(1, 0, 1) + hrp.Position * Vector3.new(0, 1, 0)

				--Making sure the NPC isn't on air, climbing or moving
				repeat 
					RunService.Heartbeat:Wait()
				until humanoid:GetState() ~= Enum.HumanoidStateType.Freefall and humanoid:GetState() ~= Enum.HumanoidStateType.Jumping and hrp.Velocity.Magnitude < 0.01 and path.Idle

				local TWEEN_INFO = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection. InOut)
				local LOOKTWEEN = TweenService:Create(hrp, TWEEN_INFO, {CFrame = CFrame.new(ORIGIN, LOOK_AT)})

				LOOKTWEEN:Play()
				--LOOKTWEEN.Completed:Wait()

				--Fire event
				self.events.Reached:Fire(REACHED_WAYPOINT, INTERACTION)

				hrp.Anchored = true

				local ENTER_ANIMATION = REACHED_WAYPOINT:FindFirstChild("Enter")
				--Detect if the waypoint has an entrance animation
				if ENTER_ANIMATION then
					local ANIMATION_TRACK = ANIMATOR:LoadAnimation(ENTER_ANIMATION)
					ANIMATION_TRACK.Looped = false
					ANIMATION_TRACK.Priority = Enum.AnimationPriority.Action2
					ANIMATION_TRACK:Play()
					ANIMATION_TRACK.Stopped:Wait()
				end

				--Detect if the waypoint has an interact animation

				local INTERACT_ANIMATIONS = {}
				--Get available animations
				for i, animation in pairs(REACHED_WAYPOINT:GetChildren()) do
					if animation:IsA("Animation") and animation.Name ~= "Enter" and animation.Name ~= "Leave" then
						table.insert(INTERACT_ANIMATIONS, animation)
					end
				end

				if #INTERACT_ANIMATIONS > 0 then
					INTERACTION = INTERACT_ANIMATIONS[math.random(1, #INTERACT_ANIMATIONS)]

					self.INTERACTION = ANIMATOR:LoadAnimation(INTERACTION)
					self.INTERACTION.Priority = Enum.AnimationPriority.Action
					self.INTERACTION:Play()
 
					task.wait(self.INTERACTION.Length)
					if self.INTERACTION.IsPlaying == true then
						task.wait(self.Debounce - self.INTERACTION.Length)
					end
				end
			end

			--Continue

			--Subwaypoints and prewaypoints
			local SUB_WAYPOINTS = importWaypoints(REACHED_WAYPOINT)

			if #SUB_WAYPOINTS > 0 then
				--Sending current path saves to sub-path

				local sendData = {
					CURRENT_INDEX = CURRENT_INDEX,
					LAST_INDEX = LAST_INDEX,
					LAST_OF_LAST_INDEX = LAST_OF_LAST_INDEX,
					FINISHED = FINISHED,
					DEBOUNCE = self.Debounce,
					RANDOMIZED = self.Randomized
				}

				self:Run(REACHED_WAYPOINT, sendData)
			else
				if FINISHED < #pathWaypoints or waypoints == self.MainPath then
					goToNextWaypoint()
				else
					if REACHED_WAYPOINT.Parent.Parent then
						local UPPER_WAYPOINTS = importWaypoints(REACHED_WAYPOINT.Parent.Parent)

						--Restoring upper path continuation
						local sendData = {
							CURRENT_INDEX = UPPER_CURRENT_INDEX,
							LAST_INDEX = UPPER_LAST_INDEX,
							LAST_OF_LAST_INDEX = UPPER_LAST_OF_LAST_INDEX,
							FINISHED = FINISHED,
							DEBOUNCE = self.Debounce,
							RANDOMIZED = self.Randomized
						}

						self:Run(REACHED_WAYPOINT.Parent.Parent, nil, sendData)
					end
				end
			end
		end

		local function goTo()
			--Fire event
			self.events.Next:Fire(CURRENT_WAYPOINT)

			hrp.Anchored = false

			--Stopping interaction
			if self.INTERACTION then
				self.INTERACTION:Stop()
				self.INTERACTION = nil
			end

			--Detect if last waypoint exists
			if pathWaypoints[LAST_INDEX] then
				--Detect if the last waypoint has an exit animation
				local LEAVE_ANIMATION = pathWaypoints[LAST_INDEX]:FindFirstChild("Leave")

				if LEAVE_ANIMATION then
					local ANIMATION_TRACK = ANIMATOR:LoadAnimation(LEAVE_ANIMATION)
					ANIMATION_TRACK.Looped = false
					ANIMATION_TRACK.Priority = Enum.AnimationPriority.Action2
					ANIMATION_TRACK:Play()
					ANIMATION_TRACK.Stopped:Wait()
				end
			end

			--Check if the npc is already at the waypoint
			local distance = ((hrp.Position * Vector3.new(1, 0, 1) + CURRENT_WAYPOINT.Position * Vector3.new(0, 1, 0)) - CURRENT_WAYPOINT.Position).Magnitude

			if distance <= reachedThreshold then
				isReached()
			else
				path:Run(CURRENT_WAYPOINT.Position)
			end
		end

		--Connections
		self.REACHED_EVENT = path.Reached:Connect(function()
			isReached()
		end)

		self.ERROR_EVENT = path.Error:Connect(function(errorType)
			if errorType == "PathTooShort" or errorType == "TargetUnreachable" then
				goTo()
			end
		end)

		self.TRAPPED_EVENT = path.Trapped:Connect(function()
			goTo()
		end)

		--Yield
		task.wait(self.Debounce)

		goTo()
	end

	--First time running
	goToNextWaypoint()
end

return agent
