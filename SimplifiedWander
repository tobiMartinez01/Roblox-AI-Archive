local wanderer = {}
--Set to be same indexes
wanderer.__index = wanderer

local random = math.random

function wanderer.new(agent, path, costs, defaultDebounce, randomized)
	local new_wander = {}
	--Bind wander to be new_wander
	setmetatable(new_wander, wanderer)
	--Insert but OOP style :P aka custom properties
	new_wander.Agent = agent
	new_wander.Path = path
	new_wander.Costs = costs
	new_wander.Debounce = defaultDebounce
	new_wander.Randomized = randomized

	--Events
	new_wander.ReachedBindable = Instance.new("BindableEvent")
	new_wander.Reached = new_wander.ReachedBindable.Event 

	return new_wander
end

function invokeReached(self, current)
	self.ReachedBindable:Fire(current)
end

local function Run(self, npc, GetPathFrom, costs, debounce, randomized, previousIndex)
	local humanoid = npc.Humanoid
	local hrp = npc.HumanoidRootPart

	--Set up
	hrp:SetNetworkOwner(nil)
	for i, bodypart in pairs(npc:GetDescendants()) do
		if bodypart:IsA("BasePart") then
			bodypart.CollisionGroup = "SelfUncollide"
		end
	end

	local raycastParams = RaycastParams.new()
	raycastParams.FilterDescendantsInstances = {npc}
	raycastParams.FilterType = Enum.RaycastFilterType.Exclude
	raycastParams.RespectCanCollide = true
	raycastParams.IgnoreWater = true

	--Workspaces
	local RunService = game["Run Service"]
	local PathFindingService = game["PathfindingService"]

	--Libraries
	local SimplePath = require(game.ServerStorage.SimplePath)

	--SimplePath
	local pathParams = {
		AgentHeight = npc:GetExtentsSize().Y,
		AgentCanJump = true,
		AgentCanClimb = true,
		--AgentRadius = 2, --Changing this can cause the agent to not running correctly
		--WaypointSpacing = 1.5,
		Costs = costs,
		PathSettings = {
			SupportPartialPath = true
		}
	}

	local path_waypoints = {}
	for i, waypoint in ipairs(GetPathFrom:GetChildren()) do
		if waypoint:IsA("BasePart") then
			table.insert(path_waypoints, waypoint)
		end
	end
	table.sort(path_waypoints, function(a, b)
		return tonumber(a.Name) < tonumber(b.Name)
	end)

	local previous = path_waypoints[previousIndex]
	local path, path_ = SimplePath.new(npc, pathParams)
	local current
	local last
	local last_of_last

	--Next index
	if randomized then
		if previous then
			repeat
				current = random(1, #path_waypoints)
			until current ~= previousIndex
		else
			current = random(1, #path_waypoints)
		end
	else
		if previous then
			current = previousIndex + 1
		else
			current = 1
		end
	end

	local function wander(_delay)
		path_waypoints[current]:SetAttribute("Unavailable", true)
		task.wait(_delay)
		path:Run(path_waypoints[current].Position)
	end

	path.Blocked:Connect(function()
		path:Run(path_waypoints[current].Position)
	end)

	path.Error:Connect(function()
		path:Run(path_waypoints[current].Position)
	end)

	local finished
	
	if previous then
		finished = previous:GetAttribute('Finished')
	else
		finished = 0
	end
	
	--print(previous)
	
	local function upper()
		if GetPathFrom.Parent then				
			local continue_wp = {}

			for i, waypoint in ipairs(GetPathFrom.Parent:GetChildren()) do
				if waypoint:IsA("BasePart") then
					table.insert(continue_wp, waypoint)
				end
			end

			table.sort(continue_wp, function(a, b)
				return tonumber(a.Name) < tonumber(b.Name)
			end)

			local current_index = table.find(continue_wp, GetPathFrom)

			Run(self, npc, GetPathFrom.Parent, costs, GetPathFrom:GetAttribute('Debounce'), GetPathFrom:GetAttribute('Randomized'), current_index)
		end
	end

	path.Reached:Connect(function()
		finished+=1
		invokeReached(self, current)
		local reached_wp = path_waypoints[current]
		reached_wp:SetAttribute("Unavailable", nil)
		debounce = reached_wp:GetAttribute('Debounce') or debounce
		randomized = reached_wp:GetAttribute('Randomized') or randomized 

		if reached_wp:FindFirstChildWhichIsA("Attachment") then
			local lookPoint = reached_wp:FindFirstChildWhichIsA("Attachment")
			npc.PrimaryPart.CFrame = CFrame.new(npc.PrimaryPart.Position, lookPoint.WorldPosition*Vector3.new(1,0,1) + npc.PrimaryPart.Position*Vector3.new(0,1,0))
		end

		local sub = reached_wp:GetChildren()
		local sub_waypoints = {}

		for i, wp in ipairs(sub) do
			if wp:IsA("BasePart") then
				table.insert(sub_waypoints, wp)
			end
		end

		if #sub_waypoints > 0 then
			reached_wp:SetAttribute('Finished', finished)
			local sub_debounce = reached_wp:GetAttribute('Sub_Debounce')
			local sub_randomized = reached_wp:GetAttribute('Sub_Randomized')
			Run(self, npc, reached_wp, costs, sub_debounce, sub_randomized)
			return
		end

		--print(npc, finished, #path_waypoints)

		if (finished < #path_waypoints) or (GetPathFrom == self.Path) then
			if randomized then
				last_of_last = last
				last = current
				if #path_waypoints > 3 then
					repeat
						current = math.random(1, #path_waypoints)
						task.wait()
					until current ~= last and current ~= last_of_last and path_waypoints[current]:GetAttribute("Unavailable") == nil
				else
					repeat
						current = math.random(1, #path_waypoints)
						task.wait()
					until current ~= last and path_waypoints[current]:GetAttribute("Unavailable") == nil
				end
			else
				repeat
					current+=1
					if current > #path_waypoints then
						current = 1
					end
					task.wait()
				until path_waypoints[current]:GetAttribute("Unavailable") == nil
			end
		else
			upper()
			return
		end

		wander(debounce)
	end)

	if (finished < #path_waypoints) or (GetPathFrom == self.Path) then
		if previous then
			wander(previous:GetAttribute('Debounce') or 0)
		else
			wander(0)
		end
	else
		upper()
		return
	end

	RunService.Heartbeat:Connect(function()
		if humanoid:GetState() ~= Enum.HumanoidStateType.Climbing then
			local origin = hrp.CFrame + (hrp.CFrame.LookVector * (hrp.Size.Z/2)) 
			local size = Vector3.new(hrp.Size.X+0.05,1,1)
			local overlap = OverlapParams.new()
			overlap.RespectCanCollide = true
			overlap.FilterType = Enum.RaycastFilterType.Exclude
			overlap.FilterDescendantsInstances = {npc}
			local obstacle = workspace:GetPartBoundsInBox(origin, size, overlap)

			for i, part in pairs(obstacle) do
				if not part:FindFirstAncestorWhichIsA('Model'):FindFirstChild("Humanoid") then
					if part.ClassName ~= "TrussPart" then
						if part.Transparency ~= 1 then
							local sides = {
								front = part.CFrame.LookVector * (part.Size.Z / 2)+part.Position,
								back = -part.CFrame.LookVector * (part.Size.Z / 2)+part.Position,
								right = part.CFrame.RightVector * (part.Size.X / 2)+part.Position,
								left = -part.CFrame.RightVector * (part.Size.X / 2)+part.Position,
								up = part.CFrame.UpVector * (part.Size.Y / 2)+part.Position,
								down = -part.CFrame.UpVector * (part.Size.Y / 2)+part.Position,
							}

							local highestSurface = nil
							local highestY = -math.huge  -- Start with a very low value to ensure any surface is higher

							for side, position in pairs(sides) do
								if position.Y > highestY then
									highestY = position.Y
									highestSurface = side
								end
							end

							if (humanoid.JumpPower^2 / (2*workspace.Gravity)) >= (highestY - hrp.Position.Y) then
								humanoid.Jump = true
							end
						end
					end
				end
			end
		end
	end)
end

function wanderer:Run()
	Run(self, self.Agent, self.Path, self.Costs, self.Debounce, self.Randomized)
end

return wanderer
