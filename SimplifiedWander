local wanderer = {}
--Set to be same indexes
wanderer.__index = wanderer

local random = math.random

function wanderer.new(agent, path, costs, defaultDebounce, randomized)
	local new_wander = {}
	--Bind wander to be new_wander
	setmetatable(new_wander, wanderer)
	--Insert but OOP style :P aka custom properties
	new_wander.Agent = agent
	new_wander.Path = path
	new_wander.Costs = costs
	new_wander.Debounce = defaultDebounce
	new_wander.Randomized = randomized

	local attachment0 = Instance.new("Attachment", agent.HumanoidRootPart)
	attachment0.CFrame = CFrame.Angles(0, math.rad(90), 0)

	local alignOrientation = Instance.new("AlignOrientation", attachment0)
	alignOrientation.MaxTorque = 10^5
	alignOrientation.MaxAngularVelocity = 100
	alignOrientation.Responsiveness = 20
	alignOrientation.Mode = Enum.OrientationAlignmentMode.OneAttachment
	alignOrientation.AlignType = Enum.AlignType.PrimaryAxisLookAt
	alignOrientation.ReactionTorqueEnabled = true
	alignOrientation.Attachment0 = attachment0

	new_wander.Attachment0 = attachment0
	new_wander.AlignOrientation = alignOrientation

	--Events
	new_wander.ReachedBindable = Instance.new("BindableEvent")
	new_wander.Reached = new_wander.ReachedBindable.Event 

	return new_wander
end

function invokeReached(self, currentIndex)
	self.ReachedBindable:Fire(currentIndex)
end

function lookEnable(self)
	self.AlignOrientation.Enabled = true
end

function lookDisable(self)
	self.AlignOrientation.Enabled = false
end

local function Run(self, npc, GetPathFrom, costs, debounce, randomized, previousIndex)
	local humanoid = npc.Humanoid
	local hrp = npc.HumanoidRootPart

	--Set up
	for i, bodypart in pairs(npc:GetDescendants()) do
		if bodypart:IsA("BasePart") then
			bodypart.CollisionGroup = "SelfUncollide"
			bodypart:SetNetworkOwner(nil)
		end
	end

	local raycastParams = RaycastParams.new()
	raycastParams.FilterDescendantsInstances = {npc}
	raycastParams.FilterType = Enum.RaycastFilterType.Exclude
	raycastParams.RespectCanCollide = true
	raycastParams.IgnoreWater = true

	--Workspaces
	local RunService = game["Run Service"]
	local PathFindingService = game["PathfindingService"]

	--Libraries
	local SimplePath = require(game.ServerStorage.SimplePath)

	--SimplePath
	local pathParams = {
		AgentHeight = npc:GetExtentsSize().Y,
		AgentCanJump = true,
		AgentCanClimb = true,
		--AgentRadius = 2, --Changing this can cause the agent to not running correctly
		--WaypointSpacing = 1.5,
		Costs = costs,
		PathSettings = {
			SupportPartialPath = true
		}
	}

	local path_waypoints = {}
	for i, waypoint in ipairs(GetPathFrom:GetChildren()) do
		if waypoint:IsA("BasePart") then
			table.insert(path_waypoints, waypoint)
		end
	end
	table.sort(path_waypoints, function(a, b)
		return tonumber(a.Name) < tonumber(b.Name)
	end)

	local currentIndex
	local current
	local previous = path_waypoints[previousIndex]
	local last
	local last_of_last
	local finished

	local path, path_ = SimplePath.new(npc, pathParams)

	--Finding next index
	if previous then
		if randomized then
			repeat
				currentIndex = math.random(1, #path_waypoints)
				task.wait()
			until currentIndex ~= previousIndex
		else
			currentIndex = previousIndex + 1
		end
		finished = previous:GetAttribute('Finished')
		previous:SetAttribute('Finished', nil)
	else
		if randomized then
			currentIndex = math.random(1, #path_waypoints) 
		else
			currentIndex = 1
		end
		finished = 0
	end

	current = path_waypoints[currentIndex]

	local function wander(_delay)
		current = path_waypoints[currentIndex]
		--print(npc.Name .. " is going to: " .. tostring(current))
		current:SetAttribute("Unavailable", true)
		task.wait(_delay)
		lookDisable(self)
		path:Run(current.Position)
	end

	local function upper_route()
		if GetPathFrom.Parent then				
			local continue_wp = {}

			for i, waypoint in ipairs(GetPathFrom.Parent:GetChildren()) do
				if waypoint:IsA("BasePart") then
					table.insert(continue_wp, waypoint)
				end
			end

			table.sort(continue_wp, function(a, b)
				return tonumber(a.Name) < tonumber(b.Name)
			end)

			local current_index_ = table.find(continue_wp, GetPathFrom)

			Run(self, npc, GetPathFrom.Parent, costs, GetPathFrom:GetAttribute('Debounce'), GetPathFrom:GetAttribute('Randomized'), current_index_)
		end
	end

	path.Reached:Connect(function()
		finished+=1
		invokeReached(self, currentIndex)
		local reached_wp = current
		reached_wp:SetAttribute("Unavailable", nil)
		debounce = reached_wp:GetAttribute('Debounce') or debounce
		randomized = reached_wp:GetAttribute('Randomized') or randomized 

		if reached_wp:FindFirstChildWhichIsA("Attachment") then
			local lookPoint = reached_wp:FindFirstChildWhichIsA("Attachment")
			lookEnable(self)
			local fixedLookAtPos = lookPoint.WorldCFrame.Position * Vector3.new(1, 0, 1) + hrp.Position * Vector3.new(0, 1, 0)
			self.AlignOrientation.LookAtPosition = hrp.Position + (fixedLookAtPos - hrp.Position).Unit
		end

		local sub = reached_wp:GetChildren()
		local sub_waypoints = {}

		for i, wp in ipairs(sub) do
			if wp:IsA("BasePart") then
				table.insert(sub_waypoints, wp)
			end
		end

		if #sub_waypoints > 0 then
			reached_wp:SetAttribute('Finished', finished)
			local sub_debounce = reached_wp:GetAttribute('Sub_Debounce')
			local sub_randomized = reached_wp:GetAttribute('Sub_Randomized')
			Run(self, npc, reached_wp, costs, sub_debounce, sub_randomized)
			return
		end

		--print(npc, finished, #path_waypoints)

		last_of_last = last
		last = currentIndex

		if (finished < #path_waypoints) or (GetPathFrom == self.Path) then
			--print("Reroll")
			if randomized then
				if #path_waypoints > 3 then
					repeat
						currentIndex = math.random(1, #path_waypoints) 
						task.wait()
					until currentIndex ~= last and currentIndex ~= last_of_last and current:GetAttribute("Unavailable") == nil
				else
					repeat
						currentIndex = math.random(1, #path_waypoints) 
						task.wait()
					until currentIndex ~= last and current:GetAttribute("Unavailable") == nil
				end
			else
				repeat
					currentIndex+=1
					if currentIndex > #path_waypoints then
						currentIndex = 1
					end
					task.wait()
				until current:GetAttribute("Unavailable") == nil
			end
		else
			upper_route()
			return
		end

		wander(debounce)
	end)

	if (finished < #path_waypoints) or (GetPathFrom == self.Path) then
		if previous then
			wander(previous:GetAttribute('Debounce') or 0)
		else
			wander(0)
		end
	else
		upper_route()
		return
	end

	path.Blocked:Connect(function()
		path:Run(current.Position)
	end)

	path.Error:Connect(function()
		path:Run(current.Position)
	end)

	path.WaypointReached:Connect(function()
		path:Run(current.Position)
	end)

	RunService.Heartbeat:Connect(function()
		if humanoid:GetState() ~= Enum.HumanoidStateType.Climbing and path.Status == SimplePath.StatusType.Active then
			local origin = hrp.CFrame + (hrp.CFrame.LookVector * (hrp.Size.Z/2)) 
			local size = Vector3.new(hrp.Size.X+0.05,1,1)
			local overlap = OverlapParams.new()
			overlap.RespectCanCollide = true
			overlap.FilterType = Enum.RaycastFilterType.Exclude
			overlap.FilterDescendantsInstances = {npc}
			local obstacle = workspace:GetPartBoundsInBox(origin, size, overlap)

			for i, part in pairs(obstacle) do
				if not part:FindFirstAncestorWhichIsA('Model'):FindFirstChild("Humanoid") then
					if part.ClassName ~= "TrussPart" then
						if part.Transparency ~= 1 then
							local sides = {
								front = part.CFrame.LookVector * (part.Size.Z / 2)+part.Position,
								back = -part.CFrame.LookVector * (part.Size.Z / 2)+part.Position,
								right = part.CFrame.RightVector * (part.Size.X / 2)+part.Position,
								left = -part.CFrame.RightVector * (part.Size.X / 2)+part.Position,
								up = part.CFrame.UpVector * (part.Size.Y / 2)+part.Position,
								down = -part.CFrame.UpVector * (part.Size.Y / 2)+part.Position,
							}

							local highestSurface = nil
							local highestY = -math.huge  -- Start with a very low value to ensure any surface is higher

							for side, position in pairs(sides) do
								if position.Y > highestY then
									highestY = position.Y
									highestSurface = side
								end
							end

							if (humanoid.JumpPower^2 / (2*workspace.Gravity)) >= (highestY - hrp.Position.Y) then
								humanoid.Jump = true
							end
						end
					end
				end
			end
		end
	end)
end

function wanderer:Run()
	Run(self, self.Agent, self.Path, self.Costs, self.Debounce, self.Randomized)
end

return wanderer
