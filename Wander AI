local path_cycles = workspace.Paths["Bricktopia Bay"].Raccoon:GetChildren()
local self = script.Parent
local target
local humanoid = self.Humanoid
local hrp = self.HumanoidRootPart

--Set up
self.PrimaryPart:SetNetworkOwner(nil)
for i, bodypart in pairs(self:GetDescendants()) do
	if bodypart:IsA("BasePart") then
		bodypart.CollisionGroup = "SelfUncollide"
	end
end

local ignored = {self}
local raycastParams = RaycastParams.new()
raycastParams.FilterDescendantsInstances = ignored
raycastParams.FilterType = Enum.RaycastFilterType.Exclude
raycastParams.RespectCanCollide = true
raycastParams.IgnoreWater = true

--Libraries
local SimplePath = require(game.ServerStorage.SimplePath)

--Workspaces
local RunService = game["Run Service"]
local PathFindingService = game["PathfindingService"]

--SimplePath
local pathParams = {
	AgentHeight = self:GetExtentsSize().Y,
	AgentCanJump = true,
	AgentCanClimb = true,
	--AgentRadius = 2, --Changing this can cause the agent to not running correctly
	--WaypointSpacing = 1,
	Costs = {
		-- Smaller = higher priority
		Climb = 1,
		Blocked = math.huge
	},
	PathSettings = {
		SupportPartialPath = true
	}
}

local current_point = 1
local debounce = 5 --Take a break!!!
local last_tick = tick()

local path, path_ = SimplePath.new(self, pathParams)
--path.Visualize = true

path.Reached:Connect(function()
	path_cycles[current_point]:SetAttribute("Unavailable", nil)
	last_tick = tick()
	current_point+= 1
	if path_cycles[current_point] then
		if path_cycles[current_point]:GetAttribute("Unavailable") == nil then
			path_cycles[current_point]:SetAttribute("Unavailable", true)
		end
	else
		current_point = 1	
		return
	end
end)

path.Blocked:Connect(function()
	humanoid.Jump = true
end)

path_cycles[current_point]:SetAttribute("Unavailable", true)

local first_time = true

RunService.Heartbeat:Connect(function()
	if tick() - last_tick >= debounce or first_time == true then
		first_time = false
		path:Run(path_cycles[current_point].Position)
		local jump = workspace:Raycast(hrp.Position, hrp.CFrame.LookVector*(hrp.Size.Z/2), raycastParams)
		if jump then
			if not jump.Instance:FindFirstAncestorWhichIsA('Model'):FindFirstChild("Humanoid") then
				if jump.Instance.ClassName ~= "TrussPart" then
					if jump.Instance.CanCollide == true then
						if jump.Instance.Transparency ~= 1 then
							local Part = jump.Instance

							local sides = {
								front = Part.CFrame.LookVector * (Part.Size.Z / 2)+Part.Position,
								back = -Part.CFrame.LookVector * (Part.Size.Z / 2)+Part.Position,
								right = Part.CFrame.RightVector * (Part.Size.X / 2)+Part.Position,
								left = -Part.CFrame.RightVector * (Part.Size.X / 2)+Part.Position,
								up = Part.CFrame.UpVector * (Part.Size.Y / 2)+Part.Position,
								down = -Part.CFrame.UpVector * (Part.Size.Y / 2)+Part.Position,
							}

							local highestSurface = nil
							local highestY = -math.huge  -- Start with a very low value to ensure any surface is higher

							for side, position in pairs(sides) do
								if position.Y > highestY then
									highestY = position.Y
									highestSurface = side
								end
							end

							if (humanoid.JumpPower^2 / (2*workspace.Gravity)) >= (highestY - hrp.Position.Y) then
								humanoid.Jump = true
							end
						end
					end
				end
			end
		end
	end
end)
