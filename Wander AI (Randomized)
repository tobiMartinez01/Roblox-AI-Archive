local path_cycles = workspace.Paths["Bricktopia Bay"].Raccoon:GetChildren()
local self = script.Parent
local target
local humanoid = self.Humanoid
local hrp = self.HumanoidRootPart

--Set up
self.PrimaryPart:SetNetworkOwner(nil)
for i, bodypart in pairs(self:GetDescendants()) do
	if bodypart:IsA("BasePart") then
		bodypart.CollisionGroup = "SelfUncollide"
	end
end

local ignored = {self}
local raycastParams = RaycastParams.new()
raycastParams.FilterDescendantsInstances = ignored
raycastParams.FilterType = Enum.RaycastFilterType.Exclude
raycastParams.RespectCanCollide = true
raycastParams.IgnoreWater = true

--Libraries
local SimplePath = require(game.ServerStorage.SimplePath)

--Workspaces
local RunService = game["Run Service"]
local PathFindingService = game["PathfindingService"]

--SimplePath
local pathParams = {
	AgentHeight = self:GetExtentsSize().Y,
	AgentCanJump = true,
	AgentCanClimb = true,
	--AgentRadius = 2, --Changing this can cause the agent to not running correctly
	WaypointSpacing = 1.5,
	Costs = {
		-- Smaller = higher priority
		Climb = 1,
		Blocked_For_Raccoons = math.huge,
		Blocked = math.huge
	},
	PathSettings = {
		SupportPartialPath = true
	}
}

local path, path_ = SimplePath.new(self, pathParams)
--path.Visualize = true

local current_point = math.random(1, #path_cycles)
path_cycles[current_point]:SetAttribute("Unavailable", true)
path:Run(path_cycles[current_point].Position)

local last_point
local last_of_the_last_point
local debounce = 5 --Take a break!!!

path.Reached:Connect(function()
	path_cycles[current_point]:SetAttribute("Unavailable", nil)
	last_of_the_last_point = last_point
	last_point = current_point

	if #path_cycles > 3 then
		repeat
			current_point = math.random(1, #path_cycles)
			task.wait(1)
		until current_point ~= last_point and current_point ~= last_of_the_last_point and path_cycles[current_point]:GetAttribute("Unavailable") == nil
	else
		repeat
			current_point = math.random(1, #path_cycles)
			task.wait(1)
		until current_point ~= last_point and path_cycles[current_point]:GetAttribute("Unavailable") == nil
	end

	if path_cycles[current_point]:GetAttribute("Unavailable") == nil then
		path_cycles[current_point]:SetAttribute("Unavailable", true)
		task.wait(debounce)
		path:Run(path_cycles[current_point].Position)
	end
end)

path.Blocked:Connect(function()
	path:Run(path_cycles[current_point].Position)
end)

path.Error:Connect(function()
	path:Run(path_cycles[current_point].Position)
end)

path.WaypointReached:Connect(function()
	path:Run(path_cycles[current_point].Position)
end)

RunService.Heartbeat:Connect(function()
	local jump = workspace:Raycast(hrp.Position, hrp.CFrame.LookVector*(hrp.Size.Z/2+0.1), raycastParams)
	if jump then
		if not jump.Instance:FindFirstAncestorWhichIsA('Model'):FindFirstChild("Humanoid") then
			if jump.Instance.ClassName ~= "TrussPart" then
				if jump.Instance.CanCollide == true then
					if jump.Instance.Transparency ~= 1 then
						local Part = jump.Instance

						local sides = {
							front = Part.CFrame.LookVector * (Part.Size.Z / 2)+Part.Position,
							back = -Part.CFrame.LookVector * (Part.Size.Z / 2)+Part.Position,
							right = Part.CFrame.RightVector * (Part.Size.X / 2)+Part.Position,
							left = -Part.CFrame.RightVector * (Part.Size.X / 2)+Part.Position,
							up = Part.CFrame.UpVector * (Part.Size.Y / 2)+Part.Position,
							down = -Part.CFrame.UpVector * (Part.Size.Y / 2)+Part.Position,
						}

						local highestSurface = nil
						local highestY = -math.huge  -- Start with a very low value to ensure any surface is higher

						for side, position in pairs(sides) do
							if position.Y > highestY then
								highestY = position.Y
								highestSurface = side
							end
						end

						if (humanoid.JumpPower^2 / (2*workspace.Gravity)) >= (highestY - hrp.Position.Y) then
							humanoid.Jump = true
						end
					end
				end
			end
		end
	end
end)
